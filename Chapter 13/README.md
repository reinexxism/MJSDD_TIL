## 13.1 스코프란?

---

<aside>

💡 스코프(유효범위)란 모든 프로그래밍 언어의 중요한 개념이며, **식별자가 유효한 범위**를 뜻한다.

</aside>

다음 예제가 어떻게 동작할 지 예측해보자

```jsx
var x = "global";

function foo() {
  var x = "local";
  console.log(x);
}

foo();
console.log(x);

// output = ?
```

- 코드의 가장 바깥 부분에 선언한 x
  - x의 스코프 : 어디에서나 참조 가능
- foo( ) 함수 내부에서 선언한 x
  - x의 스코프 : 함수 내부에서만 참조 가능
- 두 변수는 이름은 동일하지만, **스코프가 다른 별개의 변수**이다.

<br>

### 식별자 결정

이름이 같은 두 개의 변수 중에서 어떤 변수를 참조할 지 결정하는 것

즉 스코프란, 자바스크립트 엔진이 **식별자를 검색할 때 사용하는 규칙**이라고도 할 수 있다.

<br>

### 스코프를 사용하는 이유

변수나 함수의 고유한 이름인 식별자의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있도록

[주의점]

```jsx
function foo() {
  var x = 1;
  var x = 2;
  console.log(x);
}

foo();

// output
2;
```

- `var` 키워드로 선언된 변수는 동일한 스코프 내에서 중복 선언이 가능하다.
- 하지만, `let` 이나 `const` 로 선언된 변수는 중복 선언을 허용하지 않는다.

<br>

## 13.2 스코프의 종류

---

<aside>

💡 스코프는 **전역 스코프**(global scope)와 **지역 스코프**(local scope)로 구분된다.

</aside>

- 전역(global)
  - 코드의 가장 바깥 영역
  - 전역에 변수를 선언하면 전역 변수(global variable)가 된다.
  - 전역 변수는 **어디서든지 참조**할 수 있다.
- 지역(local)
  - 함수 몸체의 내부
  - 지역에 변수를 선언하면 지역 변수(local variable)가 된다.
  - 지역 변수는 **자신의 스코프와 하위 지역 스코프(중첩 함수)에서 참조**할 수 있다.

<br>

## 13.3 스코프체인

---

<aside>

💡 스코프가 계층적으로 연결된 구조를 **스코프체인(scope chain)**이라고 한다.

</aside>

<br>

다음 코드를 살펴보면,

```jsx
var x = 'global';

function outer() {
	var y = 'outer variable';
	function inner() {
		var z = 'inner variable';
		var x = 'inner variable_2';
		console.log(z, x);
	}
}

console.log(x);

// output
inner variable, inner variable_2
global
```

생성되는 지역

- outer 함수의 지역
  - outer 함수의 지역 스코프는 inner 함수의 지역 스코프의 상위 스코프이다.
  - outer 함수의 상위 스코프 : 전역 스코프
- inner 함수의 지역
  - inner 함수는 outer 함수의 중첩 함수이다.

<br>

### 계층 구조

이처럼, 모든 스코프는 **하나의 계층 구조로 연결**되며 모든 지역 스코프의 **최상위 스코프는 전역 스코프**이다.

자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하면서 선언된 변수를 검색한다.

하위 스코프로 내려가면서 식별자를 검색하는 일은 없음!

> 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 가능, **그 반대는 불가능**

<br>

## 13.4 함수 레벨 스코프

---

<aside>

💡 오로지 **함수의 코드 블록만을 지역 스코프로 인정**하는 특성이며 var 키워드로 선언된 변수일경우 적용된다.

</aside>

대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(Ex. if, for, while)이 지역 스코프를 생성한다.

하지만, `var` 키워드로 선언된 변수는 오로지 **함수의 코드 블록만을 지역 스코프로 인정**한다.

<br>

다음 코드를 살펴보면,

```jsx
var x = 1;

if (true) {
  var x = 10;
}

console.log(x);

//output
10;
```

- 전역 변수 `x`가 선언되었고, if 코드 블록 내부에도 `x` 변수가 선언되었다.
- if 문 내부에 선언된 변수는 전역 변수이다.
- var 키워드로 선언된 변수는 함수 레벨 스코프만 인정하기 때문에 if 블록은 스코프로 인정하지 않는다.

따라서, 전역 변수 `x` 는 중복 선언되고 의도치 않게 전역 변수의 값이 재할당된다.

- var : 함수 레벨 스코프 지원
- let, const : 블록 레벨 스코프 지원

<br>

## 13.5 렉시컬 스코프

---

<aside>

💡 자바스크립트에서는 렉시컬 스코프를 따르므로 함수를 호출한 위치가 아니라 **함수를 정의한 위치에 따라 상위 스코프를 결정**한다.

</aside>

다음 코드를 살펴보면,

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();

// output
1;
1;
```

위 예제의 결과는 bar 함수의 상위 스코프가 무엇인지에 따라 결정된다.

- **함수 호출 위치**에 따라 상위 스코프 결정
  - **동적 스코프**(Dynamic scope)
  - 이 방식이라면 bar 함수의 상위 스코프 : foo( ) 함수 스코프
- **함수 정의 위치**에 따라 상위 스코프 결정
  - **정적 스코프**(Static scope) 또는 **렉시컬 스코프**(Lexical scope)
  - 이 방식이라면 bar 함수의 상위 스코프 : 전역 스코프

JavaScript에서는 렉시컬 스코프를 따른다.

따라서 함수의 호출 위치는 상위 스코프 결정에 아무런 영향도 끼치지 않는다.

즉, 위 코드에서 bar() 함수의 상위 스코프는 전역 스코프이다.
