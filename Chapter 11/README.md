## Chapter11. 원시 값과 객체의 비교

<br>

## 11.1 원시 값

---

### 11.1.1 변경 불가능한 값

<aside>
💡 원시 타입(Primitive Type)의 값, 즉 원시 값은 "변경 불가능한 값(Immutable Value)"이다.

</aside>
<br>

**_값을 변경할 수 없다는 것은 무슨 의미일까?_**

<br>

**변수**

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
- 메모리 공간을 식별하기 위해 붙인 이름
- 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있다.
- 상수(변수의 상대 개념) : 재할당이 금지된 **변수**

**값**

- 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
- **변경 불가능하다는 것은 변수가 아니라 값에 대한 진술**이다!

원시 값은 변경 불가능한 값이기에 값을 직접 변경하는 것이 불가능하다.
따라서, 변수 값을 변경하기 위해 원시 값을 재할당하게 되면,

1. 새로운 메모리 공간을 확보
2. 재할당한 값을 저장
3. 기존에 변수가 참조하던 메모리 주소의 값을 변경

의 과정을 거치게 된다.
이러한 원시값의 특성을 "불변성(Immutability)"라고 한다.

불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에는 변수 값을 변경할 수 있는 수단이 없다.

<br>

> 만약, 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면?

- 예기치 않게 변수 값이 변경될 수 있다는 것을 의미
- 값의 변경, 즉 상태 변경을 추적하기 어렵게 된다는 것을 의미

<br>

### 11.1.2 문자열과 불변성

<aside>
💡 자바스크립트의 "문자열은 원시 타입"이며, 변경 불가능하다. 이것은 자바스크립트의 장점 중 하나이다.

</aside>
<br>

문자열은 **유사 배열 객체**이면서 **이터러블**이므로 배열과 유사하게 각 문자에 접근하는 것이 가능!
<br>

- 유사 배열 객체
  - 마치 배열처럼 index로 property에 접근 가능
  - length property를 가짐
- 이터러블(iterable)
  - 사전적 의미 : 반복 가능하다
  - for문으로 순회가 가능

<br>

**Q.** 문자열은 원시 값이라면서 어떻게 객체일수도 있다는거죠?

**A.** 원시 값을 객체처럼 사용하게 되면, 원시 값을 감싸는 **래퍼 객체로 자동 변환**된다. 자세한 내용은 21장에서 계속

<br>

문자열 예시

```jsx
var str = "string";

console.log(str[0]); // index를 사용하여 배열의 각 문자에 접근이 가능
console.log(str.length); // 원시 값인 문자열이 객체처럼 동작
console.log(str.toUpperCase());

// output
s;
6;
STRING;
```

```jsx
var str = "string";
str[0] = "S";

console.log(str); // 문자열은 원시 값이므로 변경할 수 없다.(Error 발생하지 않음)

// output
string;
```

<br>

### 11.1.3 값에 의한 전달(Pass by value)

<aside>

💡 변수에 원시 값을 갖는 변수를 할당 시, 할당받는 변수에는 **할당되는 변수의 원시 값이 복사되어 전달**된다.

</aside>

사실 “값에 의한 전달”이라는 표현은 JavaScript를 위한 용어가 아니다.
엄밀하게 말하자면 변수에는 값이 전달되는 것이 아니라, 메모리 주소가 전달되기 때문이다.

이는 변수와 같은 식별자는 **값이 아니라 메모리 주소를 기억**하고 있기 때문!

이처럼 “값에 의한 전달”도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다.
단, 전달된 메모리 주소를 통해 **메모리 공간에 접근하면 값을 참조**할 수 있다.

다음 코드를 살펴보면,

```jsx
var score = 80;
var copy = score; // copy변수에 score변수를 할당(score변수 : 원시 값을 갖는 변수)

console.log(score, copy);
console.log(score === copy);

score = 100; // score변수의 값을 재할당

console.log(score, copy);
console.log(copy === score);

// output
80, 80;
true;
100, 80;
false;
```

- score변수와 copy변수는 숫자 80을 갖는다는 점에서 동일하다.
- But, score변수와 copy변수의 값 80은 서로 다른 메모리 공간에 **저장된 별개의 값**이다.
- 따라서, score변수의 값을 재할당하여도 copy변수에는 적용되지 않는다.

<br>

마지막으로 정리하자면,

> 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이므로, 한 쪽에서 재할당이 이루어지더라도 **서로 간섭할 수 없다.**

<br>

## 11.2 객체

---

**객체**

- Property의 개수가 정해져 있지 않다.
- 동적으로 추가되고, 삭제하는 것이 가능하다.
- Property의 값에 제약이 없다 → 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없음
- **복합적인 자료구조**
  - 경우에 따라서는 크기가 매우 클 수도 있다.
  - 객체를 생성하고 property에 접근하는 것도 원시값과 비교했을때 비용이 많이 든다.

<br>

### 11.2.1 변경 가능한 값

<aside>
💡 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.

</aside>

**_값을 변경할 수 있다는 것은 무슨 의미일까?_**

변수에 객체를 할당하게 되면,

- 변수에는 생성된 객체가 **실제로 저장된 메모리 공간 주소**(참조 값)이 저장되어 있다.
- 변수값의 메모리 주소를 통해 메모리 공간에 접근하면, **참조 값(Reference value)에 접근**할 수 있다.
- 재할당 없이 **객체를 직접 변경하는 것이 가능**하다.
  - 객체를 할당한 변수의 참조 값은 변경되지 않는다.

객체는 구조적 단점에 따르는 부작용이 존재한다.

바로, “**여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것**” 이다.

<br>

### 11.2.2 참조에 의한 전달(Pass by reference)

<aside>

💡 객체를 가리키는 변수를 다른 변수에 할당하면, **원본의 참조 값이 복사되어 전달**된다. 이를 참조에 의한 전달이라고 한다.

</aside>

코드를 먼저 살펴보면,

```jsx
var person = {
	name: 'Choi';
};
var copy = person;              // 참조 값을 (얕은)복사, copy와 person은 동일한 참조 값을 가짐

console.log(copy === person);   // copy와 person은 동일한 객체를 참조 중

copy.name = 'Kim';              // copy를 통해서 객체를 변경
person.address = 'Seoul';       // person을 통해서 객체를 변경

console.log(person);
console.log(copy);

// output
true
{name: "kim", address: "Seoul"}
{name: "kim", address: "Seoul"}
```

원시 값과 달리, 서로 영향을 끼친다는 것을 알 수 있다.

결국,

- “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 **메모리 공간에 저장되어 있는 값을 복사해서 전달**한다는 면에서 동일
- 변수에 저장되어 있는 값이 “원시 값”이냐 “참조 값”이냐의 차이만 존재
- JavaScript에는 “값에 의한 전달”만이 존재한다고 말할 수 있다.

<br>

마지막으로 퀴즈 풀어보기!

```jsx
var person1 = {
	name: 'Choi';
};

var person2 = {
	name: 'Kim';
};

console.log(person1 === person2);
console.log(person1.name === person2.name);

// output 예측해보기
```

- 1번 console.log
  ```jsx
  true;
  ```
  - 객체 리터럴은 평가될 때마다 객체를 생성
  - person1과 person2가 가리키는 객체는 **서로 다른 메모리에 저장된 별개의 객체**이다.
  - 참조 값이 서로 다르기에 답은 **false!**
- 2번 console.log
  ```jsx
  false;
  ```
  - person1.name, person2.name은 값으로 평가될 수 있는 표현식이다.
  - **원시 값으로 판단되기에 두 값이 동일**하다고 평가된다.
  - 따라서 답은 **true**!
